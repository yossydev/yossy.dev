---
title: "TypedArray.prototype.includesのパフォーマンスを意識した実装をする"
description: "feat(ecmascript): TypedArray.prototype.includesで実装した内容について。"
date: "2025/02/10"
updatedAt: "2025/02/10"
path: "nova-typed-array-prototype-includes"
published: true
---

## Intro

[feat(ecmascript): %TypedArray%.prototype.includes](https://github.com/trynova/nova/pull/554)で実装した内容について。

## includesの仕様

[%TypedArray%.prototype.includesの仕様書](https://tc39.es/ecma262/multipage/indexed-collections.html#sec-%typedarray%.prototype.includes)を見ると、このメソッドは引数にsearchElementとfromIndexを受け取ることがわかります。

実際のコードを見ると、イメージが湧くと思います。

```js
ref: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/includes
const uint8 = new Uint8Array([10, 20, 30, 40, 50]);

console.log(uint8.includes(20, 3));
// Expected output: false
```

searchElementは探したい値（今回の場合は20）、fromIndexは、index番目を探索するという意味です。

そして今回のポイントは、このfromIndexです。

## fromIndexに何を渡されるか

おそらくほとんどの方は、fromIndexにはnumberを渡してくれるでしょう。0,1,10,100などの。
indexに100を渡すこともレアかもしれません。

ただ、JavaScriptは動的な言語になるので、ここにはなんでも好きな値を渡せます。

```js
const typedArray = new Uint8Array([10, 20, 30, 40, 50]);

typedArray.includes(30, "2")  // 文字列 → 数値に変換
typedArray.includes(30, Symbol("2"))  // Symbolはエラー
typedArray.includes(30, {})  // Objectはエラー
typedArray.includes(30, [])  // 空配列は0に
```

number以外のいろんな値を渡してみました。

当然ですが、このようにいろんな値を渡した場合の挙動も、ecma262には記載があります。

fromIndexに渡される値に関しては、[7.1.5 ToIntegerOrInfinity ( argument )](https://tc39.es/ecma262/multipage/abstract-operations.html#sec-tointegerorinfinity)に記載があり、その中の[7.1.4 ToNumber ( argument )](https://tc39.es/ecma262/multipage/abstract-operations.html#sec-tonumber)を見ると、渡した値それぞれの動きが書かれています。

例えば、`2. If argument is either a Symbol or a BigInt, throw a TypeError exception.`とあるように、SymbolとBigIntはエラーになります。お手元で試してみてください。

ここで筆者的に面白かったのはStringを渡した時の挙動です。仕様書には、`6. If argument is a String, return StringToNumber(argument).`と書かれてありますね。

たどって[7.1.4.1.1 StringToNumber ( str )](https://tc39.es/ecma262/multipage/abstract-operations.html#sec-stringtonumber)をみてみると、Stringをnumberに変換しようとして、できなかったものはNaNに変換されています。
ちなみにNaNになったものはToIntegerOrInfinity側で`2. If number is one of NaN, +0𝔽, or -0𝔽, return 0.`と書かれてあるように、0になります。

## 不要な処理をスキップして、高速に

前置きがかなり長くなってしまいましたが、何度も言っているように、ほとんどの方々はincludesのfromIndexには数字を渡してくれるはずだと思っています。

そしてNovaの思想として、そういう時にはtryメソッドというものを使用します。実際に実装したコードは以下の通りになっています。

```rs
// 5. Let n be ? ToIntegerOrInfinity(fromIndex).
let n = if let TryResult::Continue(n) =
    try_to_integer_or_infinity(agent, from_index, gc.nogc())
{
    n?
} else {
    let scoped_o = o.scope(agent, gc.nogc());
    let result = to_integer_or_infinity(agent, from_index, gc.reborrow());
    o = scoped_o.get(agent).bind(gc.nogc());
    result?
};
```

基本的にはtry_to_integer_or_infinityを実行し、Breakされればelseの方に渡ります。

コードを貼ると長くなってしまうので割愛させていただきますが、ObjectやFunctionが渡された時はBreakするようになっています。

そしてこのtryメソッドはいくつかのステップを省略し、変換処理などもネイティブコードで行うので、早くなる（はず、実は測ってない）。

一応elseの場合もあるのは、たとえ9割の人で動いてたとしても、残りの1割で動かないというのはJavaScriptエンジンとして健全ではないからです。

## まとめ

tryメソッド自体はよく使っていたんですが、今回は明確に、こうした方がいいと自分で実装しながら気づけたのでとても成長を感じました。

細かい部分でブログに残せるものが最近多いので、頑張って書いていきたい！